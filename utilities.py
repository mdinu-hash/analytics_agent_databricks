"""
Utility functions for Databricks Genie Agent
Contains Genie API integration, config creation, and MLflow tracking
"""

import os
import uuid
import logging
import datetime
import pandas as pd
from databricks.sdk import WorkspaceClient
import mlflow
import mlflow.langchain
from database_schema import database_schema, table_relationships
from databricks_langchain import ChatDatabricks

# Configuration

GENIE_SPACE_ID = "your-genie-space-id"  # Genie space ID

llm = ChatDatabricks(endpoint="databricks-claude-sonnet-4", temperature=0) # Databricks Foundation Model

# objects documentation (database schema)

def create_objects_documentation(database_schema, table_relationships):
    """
    Build comprehensive database schema context string.

    Args:
        database_schema: List of table dictionaries with columns
        table_relationships: List of relationship dictionaries

    Returns:
        str: Formatted documentation string
    """
    objects_documentation = []

    # Add all tables with all their columns AND values
    for table in database_schema:
        table_name = table['table_name']
        table_desc = table['table_description']

        # Start with table info
        table_text = f"Table {table_name}: {table_desc}\n"
        table_text += "Columns:\n"

        # Add all columns for this table
        for column_name, column_info in table['columns'].items():
            table_text += f"  - Column {column_name}: {column_info['description']}\n"

            # Add column_values if available
            column_values = column_info.get('column_values', '').strip()
            if column_values:
                table_text += f"    Values in column {column_name}: {column_values}\n"

        objects_documentation.append(table_text)

    # Add ALL table relationships
    relationships_text = "\nRelationships between Tables:\n"
    for rel in table_relationships:
        relationships_text += f"  {rel['key1']} -> {rel['key2']}\n"
    objects_documentation.append(relationships_text)

    # Join all parts
    return "\n".join(objects_documentation)


# Create objects_documentation from database schema
objects_documentation = create_objects_documentation(database_schema, table_relationships)

# ============================================================================
# CONFIG UTILITIES
# ============================================================================

def create_config(run_name: str, is_new_thread_id: bool = False, thread_id: str = None):
    """
    Create a config dictionary for LangGraph

    Args:
        run_name: Descriptive run name
        is_new_thread_id: Whether to generate a new thread_id
        thread_id: Optionally provide an existing thread_id to reuse

    Returns:
        tuple: (config dict, thread_id)
    """
    time_now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    full_run_name = f"{run_name} {time_now}"

    if is_new_thread_id or not thread_id:
        thread_id = str(uuid.uuid4())

    config = {
        'run_name': full_run_name,
        'configurable': {'thread_id': thread_id}
    }

    return config, thread_id


# ============================================================================
# DATABRICKS GENIE INTEGRATION
# ============================================================================

def query_genie(genie_space_id: str, user_question: str) -> dict:
    """
    Query Databricks Genie with a natural language question

    Args:
        genie_space_id: The Genie space ID
        user_question: Natural language question

    Returns:
        dict with keys:
            - user_question: The question asked
            - genie_status: Status of Genie execution
            - generated_sql: SQL generated by Genie
            - query_description: Description of the query
            - sql_status: Status of SQL execution
            - sql_result: Query results as DataFrame
            - error: Error message if any
    """
    w = WorkspaceClient()

    # Initialize output
    output = {
        'user_question': user_question,
        'genie_status': None,
        'generated_sql': None,
        'query_description': None,
        'sql_status': None,
        'sql_result': None,
        'error': None
    }

    try:
        # Query Genie space
        conversation = w.genie.start_conversation(space_id=genie_space_id, content=user_question)
        message_waiter = w.genie.create_message(
            space_id=genie_space_id,
            conversation_id=conversation.conversation_id,
            content=user_question
        )
        genie_result = message_waiter.result()
        output['genie_status'] = genie_result.status.value

        # Check if Genie completed
        if genie_result.status.value != 'COMPLETED':
            output['error'] = f"Genie workflow did not complete. Status: {genie_result.status.value}"
            return output

        # Check for attachments
        if not genie_result.attachments:
            output['error'] = 'No attachments found in Genie response'
            return output

        # Extract query and results
        query_found = False
        for attachment in genie_result.attachments:
            if attachment.query:
                query_found = True
                output['generated_sql'] = attachment.query.query
                output['query_description'] = attachment.query.description if hasattr(attachment.query, 'description') else None

                statement_id = attachment.query.statement_id

                # Fetch query results
                statement_result = w.statement_execution.get_statement(statement_id)

                # Get SQL execution status
                output['sql_status'] = statement_result.status.state.value

                # Check if SQL execution succeeded
                if output['sql_status'] != 'SUCCEEDED':
                    output['error'] = f"SQL execution failed with status: {output['sql_status']}"
                    return output

                # Extract results
                if statement_result.result and statement_result.result.data_array:
                    result_data = statement_result.result.data_array

                    # Get column names if available
                    column_names = None
                    if statement_result.manifest and statement_result.manifest.schema:
                        column_names = [col.name for col in statement_result.manifest.schema.columns]

                    # Format as DataFrame
                    if column_names:
                        output['sql_result'] = pd.DataFrame(result_data, columns=column_names)
                    else:
                        output['sql_result'] = pd.DataFrame(result_data)
                else:
                    output['error'] = 'Query succeeded but returned no data'

                break

        if not query_found:
            output['error'] = 'No SQL query found in attachments'

    except Exception as e:
        output['error'] = f"Exception occurred: {str(e)}"
        logging.error(f"Genie query error: {e}")

    return output


# ============================================================================
# MLFLOW TRACKING UTILITIES
# ============================================================================

def start_agent_run_mlflow(experiment_folder: str, agent_name: str, scope: str,
                           question: str = None, is_new_thread_id: bool = False,
                           thread_id: str = None) -> dict:
    """
    Create or reuse a thread, create the MLflow experiment/run

    Returns:
        dict with keys: config, run_id
    """
    # Enable autologging and set tracking to Databricks
    mlflow.langchain.autolog()
    mlflow.set_tracking_uri("databricks")

    current_month_short = datetime.datetime.now().strftime("%b%Y")
    experiment_name = f"{agent_name}_{scope}_{current_month_short}"
    experiment_path = f"{experiment_folder}/{experiment_name}"

    experiment = mlflow.get_experiment_by_name(experiment_path)
    if experiment is None:
        mlflow.create_experiment(experiment_path)
    else:
        mlflow.set_experiment(experiment_path)

    # Resolve current user
    try:
        w = WorkspaceClient()
        current_user = w.current_user.me()
        user_name = current_user.user_name if hasattr(current_user, 'user_name') else 'unknown_user'
    except Exception as e:
        user_name = 'unknown_user'
        logging.warning(f"Could not get current user: {e}")

    if is_new_thread_id or not thread_id:
        thread_id = str(uuid.uuid4())

    date_time_now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    run_name = f"Run_{agent_name}_{user_name}_{date_time_now}_{thread_id}"

    # Ensure a fresh run context
    if mlflow.active_run() is not None:
        mlflow.end_run()
    run = mlflow.start_run(run_name=run_name)

    # Log basic params
    mlflow.log_param("agent_name", agent_name)
    mlflow.log_param("scope", scope)
    mlflow.log_param("thread_id", thread_id)
    mlflow.log_param("user_name", user_name)
    mlflow.log_param("run_date", datetime.datetime.now().strftime("%Y-%m-%d"))
    mlflow.log_param("run_time", datetime.datetime.now().strftime("%H:%M"))
    mlflow.log_param("question", question)

    config = {
        'run_name': run_name,
        'configurable': {'thread_id': thread_id}
    }

    return {
        'config': config,
        'run_id': run.info.run_id
    }


def log_agent_metrics_mlflow(result: dict) -> None:
    """
    Log post-execution metrics to the active MLflow run
    """
    mlflow.set_tracking_uri("databricks")

    # Scenario
    scenario = result.get('scenario', 'Unknown')
    mlflow.log_param("scenario", scenario)

    # Genie result
    genie_result = result.get('genie_result', {})
    if genie_result:
        mlflow.log_param("genie_status", genie_result.get('genie_status'))
        mlflow.log_param("generated_sql", genie_result.get('generated_sql'))
        mlflow.log_param("sql_status", genie_result.get('sql_status'))
        if genie_result.get('error'):
            mlflow.log_param("genie_error", genie_result.get('error'))

    # Agent response
    agent_response = result.get('llm_answer')
    if agent_response:
        mlflow.log_param("agent_response", agent_response.content if hasattr(agent_response, 'content') else str(agent_response))
